
function [betas, mtx, evs] = emulator(inputs_in, data, stdev, varargin)

% user-defined sampler

% builds a single-output bss-anova emulator for a stationary dataset in an
% automated fashion

% required function inputs:

% 'inputs_in' is a matrix with
% columns corresponding to model inputs (features) and rows the different
% experimental designs (instances)

% 'data' are the output dataset used to build the function: column vector, with entries
% corresponding to rows of 'inputs'

% 'stdev' is the users best guess at the standard deviation of the noise in
% the data (observation error)

% optional inputs: 

% 'relats_in' is the output from 'varselect_thermo', which performs
% up-front variable selection for tasks with large input spaces. default is empty brackets []

% 'a' and 'b' are the shape and scale parameters of the inverse gamma distribution prior for the
% observation error variance of the data. default a = 4. b is always chosen
% such that the mode of the prior is the variance given by stdev

% 'atau' and 'btau' are the parameters of the inverse gamma distribution for the 'tau
% squared' parameter: the prior for the expansion coefficients is iid normal mean zero with
% variance equal to sigma squared times tau squared. default atau = 4 and btau scales
% such that the product of tau squared and sigma squared equals the variance of the output
% dataset. btau can also be set as an input argument.

% 'tolerance' controls how hard the function builder tries to find a better
% model once adding terms starts to show diminishing returns. a good
% default is 3 -- large datasets could benefit from higher values

% 'draws' is the total number of draws from the posterior for each tested.
% default 2000

% 'gimmie' is a boolean causing the routine to return the most complex
% model tried instead of the model with the optimum bic. default false

% 'way3' is a boolean for turning on or off 3-way interactions. default
% false

% 'threshav' is a threshold for proposing terms for elimination based on
% their mean values (larger thresholds lead to more elimination). default
% 0.01

% 'threshstda' is a threshold standard deviation -- expressed as a fraction 
% relative to the mean -- that pairs with 'threshav'.
% terms with coefficients that are lower than 'threshav' and standard deviations higher than
% 'threshstda' will be proposed for elimination (elimination will happen or not 
% based on relative BIC values). default 0.5

% 'threshstdb' is a threshold standard deviation that is independent of the
% mean value of the coefficient -- all with a standard deviation (fraction 
% relative to mean) exceeding this value will be proposed for elimination.
% default 2

% 'aic' is a boolean specifying the use of the aikaike information
% criterion. default false

% 'chimod' is the handle for a function that generates the chi matrix for
% the linear model. default 'standard'

% 'basis' is a filename for a set of basis functions. default
% 'spline_coefficient_500.txt'

% 'modparams' is a vector of parameters that will be passed to the model
% specified in 'chimod'. default []

% 'sparsity' is the max number of model terms. default is the total number
% of instances

% function outputs:

% 'betas' are a draw from the posterior distribution of coefficients: matrix, with
% rows corresponding to draws and columns corresponding to terms in the GP

% 'mtx' is the basis function interaction matrix from the
% best model: matrix, with rows corresponding to terms in the GP (and thus to the 
% columns of 'betas' and columns corresponding to inputs. a given entry in the 
% matrix gives the order of the basis function appearing in a given term in the GP.
% all basis functions indicated on a given row are multiplied together.
% a zero indicates no basis function from a given input is present in a given term

% 'ev' is a vector of BIC values from all of the models
% evaluated

if size(data, 2) ~= 1
    error('emulator: data should be a column vector');
end

if size(inputs_in, 1) ~= length(data)
    error('emulator: inputs and data must have same number of rows (instances)');
end

if ~isscalar(stdev) || (stdev <= 0)
    error('emulator: stdev is a positive scalar');
end

%optional defaults
relats_in = [];
a = 4;
b = 5*stdev^2;
taudev = std(data)/stdev;
atau = 4;
btau = 5*taudev^2;
tolerance = 3;
draws = 2000;
gimmie = false;
way3 = false;
threshav = 0.01;
threshstda = 0.5;
threshstdb = 2.0;
aic = false;
chimod = 'standard';
basis = 'spline_coefficient_500.txt';
modparams = [];
sparsity = length(data);

if mod(length(varargin),2)
    error('emulator: argument list invalid. list options like ''optional argument'', value');
end

for i=1:2:length(varargin)
    atauset = false;
    btauset = false;
    aset = false;
    switch varargin{i}
        case 'relats_in'
            relats_in = varargin{i+1};
            if ~isvector(relats_in)
                error('emulator: ''relats_in'' should be a row vector of booleans like the one generated by varselect_thermo');
            end
        case 'a'
            a = varargin{i+1};
            if ~isscalar(a) || a < 1
                error('emulator: ''a'' must be a positive scalar greater than or equal to 1');
            end
            aset = true;
        case 'atau'
            atau = varargin{i+1};
            if ~isscalar(atau) || atau < 1
                error('emulator: ''atau'' must be a positive scalar greater than or equal to 1');
            end
            atauset = true;
        case 'btau'
            btau = varargin{i+1};
            if ~isscalar(btau) || btau <= 0
                error('emulator: ''btau'' must be a positive scalar greater than or equal to 1');
            end
            btauset = true;
        case 'tolerance'
            tolerance = varargin{i+1};
            if ~isscalar(tolerance) || tolerance < 1
                error('emulator: tolerance should be an integer greater than or equal to 1');
            end
        case 'draws'
            draws = varargin{i+1};
            if ~isscalar(draws) || draws < 1
                error('emulator: draws should be an integer greater than or equal to 1');
            end
        case 'gimmie'
            gimmie = varargin{i+1};
            if ~islogical(gimmie)
                error('emulator: ''gimmie'' is true or false');
            end
        case 'way3'
            way3 = varargin{i+1};
            if ~islogical(way3)
                error('emulator: ''way3'' is true or false');
            end
        case 'threshav'
            threshav = varargin{i+1};
            if ~isscalar(threshav) || threshav < 0
                error('emulator: ''threshav'' is a positive scalar or zero');
            end
        case 'threshstda'
            threshstda = varargin{i+1};
            if ~isscalar(threshstda) || threshstda < 0
                error('emulator: ''threshstda'' is a positive scalar or zero');
            end
        case 'threshstdb'
            threshstdb = varargin{i+1};
            if ~isscalar(threshstdb) || threshstdb < 0
                error('emulator: ''threshstdb'' is a positive scalar');
            end
        case 'aic'
            aic = varargin{i+1};
            if ~islogical(aic)
                error('emulator: ''aic'' is true or false');
            end
        case 'chimod'
            chimod = varargin{i+1};
            if ~ischar(chimod)
                error('emulator: ''chimod'' is a character string');
            end
        case 'basis'
            basis = varargin{i+1};
            if ~ischar(basis)
                error('emulator: ''basis'' is a character string');
            end
        case 'modparams'
            modparams = varargin{i+1};
        case 'sparsity'
            sparsity = varargin{i+1};
            if ~isscalar(sparsity) || sparsity <= 0
                error('emulator: ''sparsity'' is a positive scalar')
            end
        otherwise
            if ischar(varargin{i})
                error(['emulator: optional variable not recognized: ' varargin{i}]);
            else
                error('emulator: optional variables must be specified with character strings');
            end
    end
    if aset
        b = (a + 1)*stdev^2;
    end
    if atauset && ~btauset
        btau = (atau + 1)*taudev^2;
    end

end

ranges = max(inputs_in) - min(inputs_in);
inputs = (inputs_in - min(inputs_in))./ranges;

gibs = gibbs(inputs, data, a, b, atau, btau, chimod, modparams, ranges, basis);


% 'n' is the number of datapoints whereas 'm' is the number of inputs
[n, m] = size(inputs);

if sum(~relats_in)
    relats = zeros(sum(~relats_in),m);
    ind = 1;
    for i=1:m
        if ~relats_in(i)
            relats(ind,i) = 1;
            ind = ind + 1;
        end
    end
    ind_in = m+1;
    for i=1:m-1
        for j=i+1:m
            if ~relats_in(ind_in)
                relats(ind,i) = 1;
                relats(ind,j) = 1;
                ind = ind + 1;
            end
            ind_in = ind_in + 1;
        end
    end
    ind_in = m + m*(m-1)/2 + 1;
    if way3
        for i=1:m-2
            for j=i+1:m-1
                for k=j+1:m
                    if ~relats_in(ind_in)
                        relats(ind,i) = 1;
                        relats(ind,j) = 1;
                        relats(ind,k) = 1;
                        ind = ind + 1;
                    end
                    ind_in = ind_in + 1;
                end
            end
        end
    end
end

mrel = sum(~relats_in);
X = [];
damtx = [];
evs = [];

% 'ind' is an integer which controls the development of new terms 
ind = 1;
greater = 0;
finished = 0;

if m == 1
    sett = 1;
elseif way3
    sett = 3;
else
    sett = 2;
end
while 1
    
    indvec = zeros(1,m);
    summ = ind;
            
    while summ
        for j=1:sett
            indvec(j) = indvec(j) + 1;
            summ = summ-1;
            if summ == 0
                break;
            end
        end
    end
    
    while 1
    
        vecs = uniqueperms(indvec);

        [mvec, ~] = size(vecs);
        killvecs = [];
        if mrel ~= 0
            for j = 1:mvec
                testvec = vecs(j,:)./vecs(j,:);
                testvec(isnan(testvec)) = 0;
                for k=1:mrel
                    if sum(testvec == relats(k,:)) == m
                        killvecs = [killvecs j];
                        break
                    end
                end
            end
            nuvecs = zeros(mvec-length(killvecs),m);
            vecind = 1;
            for j=1:mvec
                if ~sum(j==killvecs)
                    nuvecs(vecind,:) = vecs(j,:);
                    vecind = vecind + 1;
                end
            end
            vecs = nuvecs;
        end

        [vm, ~] = size(vecs);
        
        damtx = [damtx; vecs];
        [dam, ~] = size(damtx);
        if dam >= sparsity
            finished = 1;
            break;
        end
        
        [beters, ~, ~, ~, Xers, ev] = gibs.sampler(X, damtx, draws);
        
        if aic
            ev = ev + (2 - log(n))*(dam+1);
        end

        betavs = [abs(mean(beters(ceil(draws/2+1):draws,(dam-vm+2):(dam+1))))' (std(beters(ceil(draws/2+1):draws,(dam-vm+2):(dam+1)))./abs(mean(beters(ceil(draws/2+1):draws,(dam-vm+2):(dam+1)))))' ((dam-vm+2):(dam+1))'];
        betavs = sortrows(betavs);

        killset = [];
        evmin = ev;
        for i=1:vm%dam
            if (betavs(i,2) > threshstda && betavs(i,1) < threshav*mean(abs(mean(beters(ceil(draws/2+1):draws))))) || (betavs(i,2) > threshstdb)
            %if betavs(i,2) > threshstdb || (betavs(i,1) < threshav*mean(abs(mean(beters(ceil(draws/2+1):draws)))))
            %if betavs(i,2) > betavs(i,1) || betavs(i,2) > threshstda
                killtest = [killset betavs(i,3)-1];

                damtx_test = damtx;
                damtx_test(killtest, :) = [];

                [damtest,~] = size(damtx_test);

%                 Xin_test = X;
%                 killXcol = [];
%                 for ii=1:length(killtest)
%                     if killtest(ii) <= dam-vm
%                         killXcol = [killXcol (killtest(ii) + 1)];
%                     end
%                 end
%                 Xin_test(:, killXcol) = [];

                [betertest, ~, ~, ~, Xtest, evtest] = gibs.sampler(X, damtx_test, draws);
                if aic
                    evtest = evtest + (2 - log(n))*(damtest+1);
                end
                if evtest < evmin
                    killset = killtest;
                    evmin = evtest;
                    Xers = Xtest;
                    beters = betertest;
                end
            end
        end

        damtx(killset, :) = [];
        ev = evmin;
        X = Xers;

        disp([ind ev])
        
        if ev < min(evs)
            
            betas = beters;
            mtx = damtx;
            greater = 1;
            evs = [evs ev];
            
        elseif greater < tolerance
            greater = greater + 1;
            evs = [evs ev];
        else
            finished = 1;
            evs = [evs ev];
            break;
        end
        
        if m == 1
            break;
        elseif way3
            if indvec(2) > indvec(3)
                indvec(1) = indvec(1) + 1;
                indvec(2) = indvec(2) - 1;
            elseif indvec(3)
                indvec(2) = indvec(2) + 1;
                indvec(3) = indvec(3) - 1;
                if indvec(2) > indvec(1)
                    indvec(1) = indvec(1) + 1;
                    indvec(2) = indvec(2) - 1;
                end
            else
                break;
            end
        elseif indvec(2)
            indvec(1) = indvec(1) + 1;
            indvec(2) = indvec(2) - 1;
        else
            break;
        end
    
    end
    
    if finished
        break;
    end
    
    ind = ind + 1;

end

if gimmie
    betas = beters;
    mtx = damtx;
end

end